/*
 * The contents of this file are subject to the terms of the Common Development
 * and Distribution License (the License). You may not use this file except in
 * compliance with the License.
 * 
 * You can obtain a copy of the License at http://www.netbeans.org/cddl.html
 * or http://www.netbeans.org/cddl.txt.
 * 
 * When distributing Covered Code, include this CDDL Header Notice in each file
 * and include the License file at http://www.netbeans.org/cddl.txt.
 * 
 * The Original Software is NetBeans. The Initial Developer of the Original
 * Software is Sun Microsystems, Inc. Portions Copyright 1997-2007 Sun
 * Microsystems, Inc. All Rights Reserved.
 */
package org.netbeans.modules.wsdlextensions.mq.editor;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.HashMap;
import java.util.Map;
import javax.swing.SwingUtilities;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;

import org.netbeans.modules.wsdlextensions.mq.editor.event.ChangeOutlet;
import org.netbeans.modules.wsdlextensions.mq.editor.event.DocumentListenerAdapter;
import org.netbeans.modules.wsdlextensions.mq.editor.event.TextFieldFocusListener;
import org.netbeans.modules.wsdlextensions.mq.editor.model.NumberFieldDocument;
import org.netbeans.modules.wsdlextensions.mq.editor.panels.BindingsConfigurationEditorPanel;
import org.netbeans.modules.xml.wsdl.bindingsupport.spi.ExtensibilityElementConfigurationEditorComponent;
import org.openide.util.NbBundle;

/**
 * Subclass of BindingsConfigurationEditorPanel that adds controller connectives
 * (event handling et al). MAINTAINERS PLEASE NOTE: The superclass is a panel
 * that is tool-generated by the NetBeans Matisse tool.  To preserve
 * maintainability, you should not modify the superclass thru any other tool AND
 * you should not add any non layout-related code to it EVEN with the Matisse
 * tool. All concerns beyond layout, such as event-handling, input validation,
 * focus cycle customization, localization, etc., should be in this class
 * instead!
 *
 * @author Noel.Ang@sun.com
 */
final class MqBindingsConfigurationEditorPanel
        extends BindingsConfigurationEditorPanel
        implements Form.FormView {

    MqBindingsConfigurationEditorPanel(Form form) {
        super();
        init();
        this.form = form;
    }

    private void init() {
        initFocusListeners();
        initActionListeners();
        initDocumentListeners();
        initDocumentModels();
        initValidation();
    }

    /** Creates and assigns focus listeners. */
    private void initFocusListeners() {
        TextFieldFocusListener listener;

        // 'hostname' field focus listener
        listener = new TextFieldFocusListener(mHostTextField, null);
        mHostTextField.addFocusListener(listener);

        // 'port' field focus listener
        listener = new TextFieldFocusListener(mPortTextField, null);
        mPortTextField.addFocusListener(listener);
        
        // 'queue manager' field focus listener
        listener = new TextFieldFocusListener(mQueueManagerTextField, null);
        mQueueManagerTextField.addFocusListener(listener);

        // 'queue' field focus listener
        listener = new TextFieldFocusListener(mQueueTextField, null);
        mQueueTextField.addFocusListener(listener);

        // 'channel' field focus listener.
        listener = new TextFieldFocusListener(mChannelTextField, null);
        mChannelTextField.addFocusListener(listener);

        // 'polling interval' field focus listener.
        listener = new TextFieldFocusListener(mPollIntervalTextField, null);
        mPollIntervalTextField.addFocusListener(listener);
    }

    /** Creates and assigns action listeners. */
    private void initActionListeners() {
        ActionListener listener;

        // Installs an action listener that will bring up the
        // Queue Manager 'Advanced' settings dialog.
        final Dialog qmDialog = new QueueManagerSettingsDialog();
        qmDialog.pack();
        listener = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                MqBindingsFormModel importModel =
                        new MqBindingsConfigurationEditorModel();
                importModel.adopt(form.getModel());
                write(importModel);
                qmDialog.getForm().importModel(importModel);
                qmDialog.setLocationRelativeTo(
                        MqBindingsConfigurationEditorPanel.this
                );
                qmDialog.setVisible(true);
                load(qmDialog.getForm().getModel());
                if (mQueueManagerAdvancedButton.isEnabled()) {
                    mQueueManagerAdvancedButton.requestFocusInWindow();
                } else {
                    mQueueManagerTextField.requestFocusInWindow();
                }
            }
        };
        mQueueManagerAdvancedButton.addActionListener(listener);

        // Installs an action listener that will bring up the
        // Queue 'Advanced' settings dialog.
        final Dialog qDialog = new QueueSettingsDialog();
        qDialog.pack();
        listener = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                MqBindingsFormModel importModel =
                        new MqBindingsConfigurationEditorModel();
                importModel.adopt(form.getModel());
                write(importModel);
                qDialog.getForm().importModel(importModel);
                qDialog.setLocationRelativeTo(MqBindingsConfigurationEditorPanel.this);
                qDialog.setVisible(true);
                load(qDialog.getForm().getModel());
                if (mQueueAdvancedButton.isEnabled()) {
                    mQueueAdvancedButton.requestFocusInWindow();
                } else {
                    mQueueTextField.requestFocusInWindow();
                }
            }
        };
        mQueueAdvancedButton.addActionListener(listener);

        // This listener changes the syncpoint checkbox state when
        // the transaction checkbox is set/unset.
        // When transactionality is checked, syncpoint is checked and disabled;
        // When transactionality is unchecked, the syncpoint is enabled.
        mTransactionalCheckbox.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                if (e.getSource() == mTransactionalCheckbox) {
                    boolean selected = mTransactionalCheckbox.isSelected();
                    mSyncpointCheckbox.setEnabled(!selected);
                    if (selected) {
                        mSyncpointCheckbox.setSelected(true);
                    }
                }
            }
        }
        );
    }

    /** Creates and assigns document listeners */
    private void initDocumentListeners() {
        // This document listener is for disabling
        // Port and Channel fields unless the Host field is not empty.
        mHostTextField.getDocument()
                .addDocumentListener(new DocumentListener() {
                    private void evaluateAssociateFields(Document document) {
                        String text = "";
                        int length = document.getLength();
                        if (length != 0) {
                            try {
                                text = document.getText(0, length);
                            } catch (BadLocationException e1) {
                                text = "";
                            }
                        }
                        boolean enableAssociateFields = false;
                        for (int idx = 0; idx < length; ++idx) {
                            if (!Character.isWhitespace(text.charAt(idx))) {
                                enableAssociateFields = true;
                                break;
                            }
                        }
                        mPortTextField.setEnabled(enableAssociateFields);
                        mChannelTextField.setEnabled(enableAssociateFields);
                    }

                    public void insertUpdate(DocumentEvent e) {
                        evaluateAssociateFields(e.getDocument());
                    }

                    public void removeUpdate(DocumentEvent e) {
                        evaluateAssociateFields(e.getDocument());
                    }

                    public void changedUpdate(DocumentEvent e) {
                        evaluateAssociateFields(e.getDocument());
                    }
                }
                );
        
        // This listener is for disabling the buttons for
        // queue and queue manager advance settings if
        // queue or queue manage fields are empty.
        mQueueTextField.getDocument()
                .addDocumentListener(new DocumentListener() {
                    private void evaluateAssociateFields(Document document) {
                        String text = "";
                        int length = document.getLength();
                        if (length != 0) {
                            try {
                                text = document.getText(0, length);
                            } catch (BadLocationException e1) {
                                text = "";
                            }
                        }
                        boolean enableAssociateFields = false;
                        for (int idx = 0; idx < length; ++idx) {
                            if (!Character.isWhitespace(text.charAt(idx))) {
                                enableAssociateFields = true;
                                break;
                            }
                        }
                        mQueueAdvancedButton.setEnabled(enableAssociateFields);
                    }

                    public void insertUpdate(DocumentEvent e) {
                        evaluateAssociateFields(e.getDocument());
                    }

                    public void removeUpdate(DocumentEvent e) {
                        evaluateAssociateFields(e.getDocument());
                    }

                    public void changedUpdate(DocumentEvent e) {
                        evaluateAssociateFields(e.getDocument());
                    }
                });
        
        mQueueManagerTextField.getDocument()
                .addDocumentListener(new DocumentListener() {
                    private void evaluateAssociateFields(Document document) {
                        String text = "";
                        int length = document.getLength();
                        if (length != 0) {
                            try {
                                text = document.getText(0, length);
                            } catch (BadLocationException e1) {
                                text = "";
                            }
                        }
                        boolean enableAssociateFields = false;
                        for (int idx = 0; idx < length; ++idx) {
                            if (!Character.isWhitespace(text.charAt(idx))) {
                                enableAssociateFields = true;
                                break;
                            }
                        }
                        mQueueManagerAdvancedButton.setEnabled(enableAssociateFields);
                    }

                    public void insertUpdate(DocumentEvent e) {
                        evaluateAssociateFields(e.getDocument());
                    }

                    public void removeUpdate(DocumentEvent e) {
                        evaluateAssociateFields(e.getDocument());
                    }

                    public void changedUpdate(DocumentEvent e) {
                        evaluateAssociateFields(e.getDocument());
                    }
                });
    }

    /** Creates customized document models for certain fields to restrict input. */
    private void initDocumentModels() {
        mPollIntervalTextField.setDocument(new NumberFieldDocument());
        mPortTextField.setDocument(new NumberFieldDocument());
    }

    /**
     * Creates various listeners for various panel elements that are significant
     * in indicating that the panel has changed state in some global wway (e.g.,
     * ready to be nominated as being complete or "done"). This is used to
     * notify the host descriptor/wizard so that it can check whether to
     * enable/disable "Next"/"Finish" button(s), etc.
     * 
     * @see #setChangeSupport
     */
    private void initValidation() {
        // I am interested in evaluating the readiness of the panel
        // when any of the following fields change:
        //     host
        //     port
        //     channel
        //     polling interval
        //     queue manager
        //     queue
        //
        // This listener is interested when anything changes,
        // regardless of the kind of change. This listener is for
        // notifying entities responsible for re-evaluating the completeness
        // of the panel's data.
        ChangeOutlet outlet = new ChangeOutlet() {
            public void notifyChange(Object context) {
                ChangeOutlet proxied = changeOutlet; // volatile
                if (proxied != null) {
                    proxied.notifyChange(context);
                }
            }
        };
        DocumentListener listener = new DocumentListenerAdapter(outlet);
        mHostTextField.getDocument().addDocumentListener(listener);
        mChannelTextField.getDocument().addDocumentListener(listener);
        mQueueManagerTextField.getDocument().addDocumentListener(listener);
        mQueueTextField.getDocument().addDocumentListener(listener);

        // This listener performs field value validation.
        // Note:
        // (1) There is only one listener for all the following fields. The
        //     listener MUST be shared, because the notification system only
        //     remembers the last posted validation error. For example,
        //     two validation errors are outstanding, therefore two notices were
        //     issued. One of the errors is corrected, and then its notice
        //     cleared.  There is no memory of the other notice, and the system
        //     allows the data to be saved.  Everytime a value is evaluated,
        //     all OTHER values subject to validation must be reevaluated.
        // (2) It is a document listener. Focus and action listeners
        //     are insufficient without wiring both kinds, because after
        //     entering a field's value, the user may choose to either change
        //     focus or immediately commit the action (e.g., press ENTER).
        ChangeOutlet validator = new FieldValidator();
        listener = new DocumentListenerAdapter(validator);
        mHostTextField.getDocument().addDocumentListener(listener);
        mChannelTextField.getDocument().addDocumentListener(listener);
        mQueueManagerTextField.getDocument().addDocumentListener(listener);
        mQueueTextField.getDocument().addDocumentListener(listener);
        mPollIntervalTextField.getDocument().addDocumentListener(listener);
        mPortTextField.getDocument().addDocumentListener(listener);
    }

    private void notifyChange() {
        ChangeOutlet outlet = changeOutlet; // volatile
        if (outlet != null) {
            outlet.notifyChange(null);
        }
    }
    
    /**
     * Populate the form's internal data model with the information provided. If
     * the supplied model is not a type that is recognized or meaningful, it is
     * disregarded.
     *
     * @param data A supported FormModel instance.
     */
    public synchronized void load(final Form.FormModel data) {
        if (!SwingUtilities.isEventDispatchThread()) {
            Utils.dispatchToSwingThread("load", new Runnable() {
                public void run() {
                    load(data);
                }
            }
            );
            return;
        }
        if (data instanceof MqBindingsFormModel) {
            MqBindingsFormModel model = (MqBindingsFormModel) data;
            form.getModel().adopt(data);
            mQueueManagerTextField.setText(model.getQueueManager());
            mQueueTextField.setText(model.getQueue());
            mChannelTextField.setText(model.getChannel());
            mHostTextField.setText(model.getHost());
            mPortTextField.setText(model.getPort());
            mPollIntervalTextField.setText(model.getPolling());
            mTransactionalCheckbox.setSelected(model.getIsTransactional());
            mSyncpointCheckbox.setSelected(model.getIsSyncpoint());
            mMessageTypeComboBox.setSelectedItem(model.getMessageType());
            
            mQueueAdvancedButton.setEnabled(!"".equals(model.getQueue()));
            mQueueManagerAdvancedButton.setEnabled(!"".equals(model.getQueueManager()));
            
            notifyChange();
        }
    }

    /**
     * Populate a model object with the data in the view. If the supplied model
     * is not a type that is recognized or meaningful, it can be disregarded.
     *
     * @param data A supported FormModel instance
     */
    public synchronized void write(final Form.FormModel data) {
        if (!SwingUtilities.isEventDispatchThread()) {
            Utils.dispatchToSwingThread("write", new Runnable() {
                public void run() {
                    write(data);
                }
            }
            );
            return;
        }
        if (data instanceof MqBindingsFormModel) {
            MqBindingsFormModel model = (MqBindingsFormModel) data;
            model.adopt(form.getModel());
            model.setQueueManager(mQueueManagerTextField.getText());
            model.setQueue(mQueueTextField.getText());
            model.setIsTransactional(mTransactionalCheckbox.isSelected());
            model.setIsSyncpoint(mSyncpointCheckbox.isSelected());
            model.setMessageType(mMessageTypeComboBox.getSelectedItem().toString());
        
            // Certain fields are irrelevant when they are part of an
            // incomplete group. For example, the port field needs the host field.
            // Treat irrelevant fields as if they have no value.
            String value = mHostTextField.getText();
            model.setHost(value);
            if (!"".equals(value)) {
                model.setPort(mPortTextField.getText());
                model.setChannel(mChannelTextField.getText());
            } else {
                model.setPort("");
                model.setChannel("");
            }
        
            // Other fields are irrelevant if they're disabled.
            if (mPollIntervalTextField.isEnabled()) {
                model.setPolling(mPollIntervalTextField.getText());
            } else {
                model.setPolling("");
            }
        }
    }

    public synchronized void setInputMode(
            MqBindingsConfigurationEditorForm.BindingMode inputMode) {
        switch (inputMode) {
            case ONEWAYGET:
                mPortTextField.setEnabled(false);
                mChannelTextField.setEnabled(false);
                break;
            case ONEWAYPUT:
                mPortTextField.setEnabled(false);
                mChannelTextField.setEnabled(false);
                mPollIntervalTextField.setEnabled(false);
                break;
            case TWOWAYGET:
                mPortTextField.setEnabled(false);
                mChannelTextField.setEnabled(false);
                mPollIntervalTextField.setEnabled(false);
                break;
            default:
        }
    }

    public synchronized void setChangeSupport(ChangeOutlet outlet) {
        changeOutlet = outlet;
    }

    private volatile ChangeOutlet changeOutlet;
    private final Form form;

    class FieldValidator
            implements ChangeOutlet {
        
        private String createErrorMessageMandatoryValue(String name) {
            return NbBundle.getMessage(FieldValidator.class,
                    "FieldValidator.MandatoryValueMsg",
                    name
            );
        }
        
        private void validate(Document subject) {
            synchronized (messages) {
                // Host field - not validated
                
                // Channel field - required if host is not blank
                if (!"".equals(mHostTextField.getText().trim())) {
                    if ("".equals(mChannelTextField.getText().trim())) {
                        messages.put(mChannelTextField.getDocument(),
                                createErrorMessageMandatoryValue(mChannelLabel.getText())
                        );
                    }
                }
                
                // Port field - required if host is not blank
                if (!"".equals(mHostTextField.getText())) {
                    String text = mPortTextField.getText();
                    int intValue;
                    try {
                        intValue = Integer.valueOf(text);
                    } catch (NumberFormatException e) {
                        intValue = 0;
                    }
                    if (intValue < 1 || 65535 < intValue) {
                        messages.put(mPortTextField.getDocument(), portRangeMsg);
                    }
                }
                
                // Queue manager field - mandatory
                if ("".equals(mQueueManagerTextField.getText().trim())) {
                    messages.put(mQueueManagerTextField.getDocument(),
                            createErrorMessageMandatoryValue(mQueueManagerLabel.getText())
                    );
                }
                
                // Queue field - mandatory
                if ("".equals(mQueueTextField.getText().trim())) {
                    messages.put(mQueueTextField.getDocument(),
                            createErrorMessageMandatoryValue(mQueueLabel.getText())
                    );
                }
                
                // Poll interval field - required if field is not disabled
                if (mPollIntervalTextField.isEnabled()) {
                    String text = mPollIntervalTextField.getText();
                    long longValue;
                    try {
                        longValue = Long.valueOf(text);
                    } catch (NumberFormatException e) {
                        longValue = -1;
                    }
                    // 31536000000L == 365 days
                    if (longValue < 0 || 31536000000L < longValue) {
                        messages.put(mPollIntervalTextField.getDocument(),
                                pollRangeMsg
                        );
                    }
                }
                
                // Show validation notice, if any, for component value in regard.
                // If the value is OK, but others are not, report any other
                // matter.
                String message = messages.get(subject);
                if (message == null && !messages.isEmpty()) {
                    message = messages.values().iterator().next();
                }
                if (message != null) {
                    MqBindingsConfigurationEditorPanel.this.firePropertyChange(
                            ExtensibilityElementConfigurationEditorComponent.
                                    PROPERTY_ERROR_EVT,
                            null,
                            message
                    );
                } else {
                    MqBindingsConfigurationEditorPanel.this.firePropertyChange(
                            ExtensibilityElementConfigurationEditorComponent.
                                    PROPERTY_CLEAR_MESSAGES_EVT,

                            null,
                            ""
                    );
                }
                messages.clear();
            }
        }
        
        public void notifyChange(Object context) {
            if (context instanceof DocumentEvent) {
                validate(((DocumentEvent) context).getDocument());
            }
        }

        private final Map<Document, String> messages =
                new HashMap<Document, String>();
        
        private final String pollRangeMsg = NbBundle.getMessage(
                FieldValidator.class,
                "FieldValidator.PollValueOutOfRange"
        );

        private final String portRangeMsg = NbBundle.getMessage(
                FieldValidator.class,
                "FieldValidator.PortValueOutOfRange"
        );
    }
}
