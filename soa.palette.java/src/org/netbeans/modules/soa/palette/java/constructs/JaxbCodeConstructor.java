package org.netbeans.modules.soa.palette.java.constructs;

import org.netbeans.modules.soa.palette.java.util.OTDImportConstants;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.util.HashMap;
import java.util.Map;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;

/**
 *
 * @author lyu
 */
public class JaxbCodeConstructor {
    /**
     * Static function which can be called to create a JAXB_XSD_DOM representing 
     * an XSD which is represented by some generated Jaxb classes.
     * 
     * @param jaxbClassName Root class name of the XSD as generated by jaxb
     * @param classloader   Classloader to use when instantiating the jaxb objects.
     * 
     * @return              JAXB_XSD_DOM which represents the XSD
     * 
     * @throws java.lang.ClassNotFoundException
     * @throws java.text.ParseException
     */
    static JAXB_XSD_DOM createDOM(String jaxbClassName, ClassLoader classloader) throws ClassNotFoundException, ParseException {
        // Varaibles
            JAXB_XSD_DOM dom;
            Class jaxbInstanceClass;
            
        // Retreive class for the JaxbInstanceObject
            try {
                jaxbInstanceClass = classloader.loadClass(jaxbClassName);
            } catch (ClassNotFoundException cnfe) {
                throw new ClassNotFoundException("The JAXB Instance class \"" + jaxbClassName + "\" could not be found.  Please check the classpath to ensure the class is in the classpath.");
            }        
            
        // Initialize the DOM by parsing the jaxb instance
            dom = new JAXB_XSD_DOM();            
            try {
                JAXBClassParseContext ctx = new JAXBClassParseContext();
                dom.setClassParserCtx(ctx);
                dom.parse(jaxbInstanceClass, ctx);
            } catch (ParseException pe) {
                throw new ParseException("An error occurred while building the DOM structure for the jaxb generated class \"" + jaxbInstanceClass.getName() + "\"\n" + pe.toString(), 0);
            }
            
        // Success!
            return dom;        
    }

    /**
     * Helper function to invoke a method on an instance of a class.  The args
     * should contain an alternating list of class types and actual arguments.
     * For example if the method to be invoked takes two parameters String and
     * Integer the args list would look like { String.class, "Hello World",
     * Integer.class, 5 }
     * 
     * @param c          class which contains the method to invoke
     * @param obj        instance of the class to invoke the method on
     * @param methodName name of the method to invoke
     * @param args       variable length argument list of arguments to invoke the
     *                   method with.  The list should alternate between class types
     *                   and actual parameters.
     * 
     * @return           whatever is returned by the invoked method
     * 
     * @throws java.lang.NoSuchMethodException
     * @throws java.lang.IllegalAccessException
     * @throws java.lang.reflect.InvocationTargetException
     */
    static Object invoke(Class c, Object obj, String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        // Variables
            Class[] cpa;
            Method m;
            Object[] opa;
            
        // Build the class parameter array
            cpa = new Class[args.length / 2];
            for (int i = 0; i < args.length; i = i + 2) {
                cpa[i / 2] =(Class) args[i];
            }

        // Build the object parameter array
            opa = new Object[args.length / 2];
            for (int i = 0; i < args.length; i = i + 2) {
                opa[(i / 2)] = args[i + 1];
            }
            
        // Find the method
            m = c.getMethod(methodName, cpa);
            
        // Invoke
            return m.invoke(obj, opa);
    }
    
    /**
     * Static function which can be called to unmarshall an xml file into a set
     * of Jaxb generated classes which repesents an XSD for the xml file.
     * 
     * @param jaxbClassName Name of the generated Jaxb class which should be used
     *                      as the root of this document.
     * @param filename      Name of the file containing the xml data
     * @param classloader   Classloader to use when instantiating Jaxb Objects
     * 
     * @return              A Jaxb Object which is the root of the unmarshalled
     *                      document.
     * 
     * @throws java.lang.ClassNotFoundException
     * @throws java.io.IOException
     * @throws javax.xml.bind.JAXBException
     * @throws java.lang.NoSuchMethodException
     * @throws java.lang.IllegalAccessException
     * @throws java.lang.reflect.InvocationTargetException
     */
    static Object unmarshalXML(String jaxbClassName, String filename, ClassLoader classloader) throws ClassNotFoundException, IOException, JAXBException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        // Variables
            Class jaxbInstanceClass;
            Object jaxbObject = null;
            Object objJaxbContext;
            Object objUnmarshaller;
            String xml;
            
        // Create the jaxbinstance
        // Retreive class for the JaxbInstanceObject
            try {
                jaxbInstanceClass = classloader.loadClass(jaxbClassName);
            } catch (ClassNotFoundException cnfe) {
                throw new ClassNotFoundException("The JAXB Instance class \"" + jaxbClassName + "\" could not be found.  Please check the classpath to ensure the class is in the classpath.");
            }        

        // Read the sample xml file
            try {
                // Local Variables                    
                    byte[] b;
                    FileInputStream fis = new FileInputStream(filename);
                    
                // Read the file                    
                    b = new byte[fis.available()];
                    fis.read(b);
                    xml = new String(b);
            } catch (FileNotFoundException fnfe) {
                throw new IOException("The sample input file \"" + filename + "\" was not found.");
            } catch (IOException ioe) {
                throw new IOException("A problem occured while reading the sample input file \"" + filename + "\"\n" + ioe.toString());
            }
            
        // Create the JAXBContext
            objJaxbContext = invoke(classloader.loadClass("javax.xml.bind.JAXBContext"), null, "newInstance", String.class, jaxbInstanceClass.getPackage().getName(), ClassLoader.class, classloader);

        // Create the unmarshaller
            objUnmarshaller = invoke(objJaxbContext.getClass(), objJaxbContext, "createUnmarshaller");                

        // Unmarshal
            jaxbObject = invoke(objUnmarshaller.getClass(), objUnmarshaller, "unmarshal", InputStream.class, new ByteArrayInputStream(xml.getBytes()));
            if (jaxbObject.getClass().getName().equals(JAXBElement.class.getName())) {
                jaxbObject = invoke(jaxbObject.getClass(), jaxbObject, "getValue");
            }        
                
        // Success!
            return jaxbObject;
    }
    
    /**
     * Static function used to construct code which will load a jaxb object
     * with correct data as specified by an input XML file.
     * 
     * @param jaxbClassName Name of the generated Jaxb class which should be used
     *                      as the root of this document.
     * @param filename      Name of the file containing the xml data
     * @param classloader   Classloader to use when instantiating Jaxb Objects
     * 
     * @return              A Map containing two sets of data.  The first set of
     *                      data is the list of imports used by this generated code.
     *                      The second set of data is the actual generated code.
     *                      Use the two keys OTDImportConstants.MAP_KEY_IMPORTS and
     *                      OTDImportConstants.MAP_KEY_METHOD_BODY
     * 
     * @throws java.lang.Exception
     */
    public static Map constructCode(String jaxbClassName, String SampleFileName, 
            ClassLoader classloader, ConstructsProgressReporter h) throws Exception {
        // Variables
            CodeGen cgen;
            JAXB_XSD_DOM dom;
            HashMap<String, Object> retMap;
            Object obj;
            String s;

        // Initialize
            retMap = new HashMap<String, Object>();
            
        // Catch any exceptions
            try {
                // Initialize
                    cgen = new CodeGen(h);
                    obj = null;
                    if (SampleFileName != null) {
                        obj = unmarshalXML(jaxbClassName, SampleFileName, classloader);
                    }
                    if (h != null){
                        h.creatingNodes();
                    }
                    dom = createDOM(jaxbClassName, classloader);

                    if (h != null){
                        h.generatingCode(dom.getClassParserCtx().getNodesCreated());
                    }
                    
                    // Clean up the code a little
                    s = cgen.generateCodeForNode(dom.getRootNode(), 0, obj, "\t");
                    s = s + "return " + dom.getRootNode().getName().toLowerCase() + ";\n";
                    
                    // Add some dummy entries
                    retMap.put(OTDImportConstants.MAP_KEY_IMPORTS, cgen.generateImportStatements());
                    retMap.put(OTDImportConstants.MAP_KEY_METHOD_BODY, s);
                    if (dom.getClassParserCtx().isDatatypeFactoryUsed()){
                        List<String> clss = new ArrayList<String>();
                        clss.add("javax.xml.datatype.DatatypeConfigurationException");//NOI18N
                        retMap.put(OTDImportConstants.MAP_KEY_METHOD_THROWS, clss); 
                    }
            } catch (Exception E) {
                throw(E);
            }
                    
        // Success!
            return retMap;
    }

    /**
     * Static Main function used for debugging.  See usage information for how
     * to use the args.
     * 
     * @param args See usage information
     */
    public static void main(String[] args) {
        // Variables
            Class jaxbInstanceClass;
            CodeGen_JUnit cgen;
            String s;
            JAXB_XSD_DOM dom;
            JAXBContext jaxbCtx;
            Object jaxbObject = null;
            Unmarshaller unmarshaller;
            String xml;
            String basename;
            String basepath;
            String extension;

        // Usage information
            if (args.length != 3) {
                System.out.println("Usage: java org.netbeans.modules.soabi.palette.java.constructs.JaxbCodeConstructor JaxbRootClassName XMLFile OutputFile");
                System.out.println("");
                System.out.println("  ex: java org.netbeans.modules.soabi.palette.java.constructs.JaxbCodeConstructor com.stc.jaxbgen.schema2.Z C:\\Test.xml C:\\Generated.java");
                System.out.println("");
                System.out.println("    JaxbRootClassName - Classname of a jaxb root element generated by the jaxb");
                System.out.println("                        compiler.");
                System.out.println("    XMLFile           - Path to an xml file which will be unmarshalled by the ");
                System.out.println("                        JaxbRootClassname class.");
                System.out.println("    OutputFile        - Path where the generated output source code file should");
                System.out.println("                        be placed");
                System.out.println("");
                return;
            }
            
        // Decode the target filename
            {
                // Local Variables
                    File f = new File(args[2]);
                    int i;
                                        
                // Decode base path
                    basepath = f.getParent();
                    
                // Decode base name and extension
                    basename = f.getName();
                    extension = "";
                    i = basename.lastIndexOf(".");
                    if (i > 0) {
                        extension = basename.substring(i);
                        basename = basename.substring(0, i);
                    }
            }

        // Read the sample xml file
            try {
                // Local Variables                    
                    byte[] b;
                    FileInputStream fis = new FileInputStream(args[1]);
                    
                // Read the file                    
                    b = new byte[fis.available()];
                    fis.read(b);
                    xml = new String(b);
            } catch (FileNotFoundException fnfe) {
                System.err.println("The sample input file \"" + args[1] + "\" was not found.");
                return;
            } catch (IOException ioe) {
                System.err.println("A problem occured while reading the sample input file \"" + args[1] + "\"\n" + ioe.toString());
                return;
            }            

        // Initialize
            try {
                jaxbObject = unmarshalXML(args[0], args[1], ClassLoader.getSystemClassLoader());
                dom = createDOM(args[0], ClassLoader.getSystemClassLoader());
            } catch (Exception E) {
                System.err.println(E.toString());
                return;
            }
            
        // Initialize CodeGen
            cgen = new CodeGen_JUnit(); 
            
        // Write out test files
            try{
                // Variables
                    BufferedWriter bw;
                    FileWriter fw;
                    String p;

                // Generate Tree Dump
                    fw = new FileWriter(basepath + File.separator + basename + "_TreeDump");
                    bw = new BufferedWriter(fw);
                    s = dom.getRootNode().toString();
                    bw.write(s);
                    bw.close();
                    
                // Generate code
                    fw = new FileWriter(basepath + File.separator + basename + extension);
                    bw = new BufferedWriter(fw);
                    s = cgen.generateCode(dom.getRootNode(), basename, jaxbObject);
                    bw.write(s);
                    bw.close();
                    
                // Generate test case
                    fw = new FileWriter(basepath + File.separator + basename + "_TestCase" + extension);
                    bw = new BufferedWriter(fw);
                    s = cgen.generateTestCase(dom.getRootNode(), basename, jaxbObject, xml);
                    bw.write(s);
                    bw.close();

                // Generate test suite
                    fw = new FileWriter(basepath + File.separator + basename + "_TestSuite" + extension);
                    bw = new BufferedWriter(fw);
                    s = cgen.generateTestSuite(dom.getRootNode(), basename, jaxbObject);
                    bw.write(s);
                    bw.close();
                    
                // Generate code fragments
                // Generate code
                    fw = new FileWriter(basepath + File.separator + basename + "_CodeFragments");
                    bw = new BufferedWriter(fw);
                    Map map = JaxbCodeConstructor.constructCode(args[0], args[1], 
                            ClassLoader.getSystemClassLoader(), null);
                    s = "";
                    s = s + "// IMPORTS\n\n" + map.get(OTDImportConstants.MAP_KEY_IMPORTS).toString() + "\n\n";
                    s = s + "// METHOD\n\n" + map.get(OTDImportConstants.MAP_KEY_METHOD_BODY).toString() + "\n\n";
                    bw.write(s);
                    bw.close();
                    
            }catch (Exception E) {
                E.printStackTrace();
            }
    }          
}